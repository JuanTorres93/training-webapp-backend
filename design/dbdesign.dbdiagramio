// Use DBML to define your database structure
// Docs: https://dbml.dbdiagram.io/docs

Project training_webapp {
  database_type: 'PostgreSQL'
}

Table subscriptions {
  id UUID [PK]
  type VARCHAR(20) [NOT NULL, UNIQUE, Note: 'Internal label for identification']
  description TEXT [NOT NULL, Note: 'Description to shown in frontend']
  base_price_in_eur_cents INTEGER [NOT NULL]
  name VARCHAR(60) [NOT NULL, Note: 'Name in English and Spanish that will appear in the frontend']
  description_internal TEXT [Note: 'Description for internal use: to know what the subscription is for']
}

Table users {
  id UUID [PRIMARY KEY]
  username VARCHAR(40) [NOT NULL, UNIQUE]
  email VARCHAR(70) [NOT NULL, UNIQUE]
  subscription_id UUID [ref: > subscriptions.id, not null]
  last_name VARCHAR(40)
  img TEXT [Note: 'Image will be stored in server. This will be its URI. ALTERNATIVELY: store it in Postgres DB']
  second_last_name VARCHAR(40)
  password VARCHAR(60) [NOT NULL, Note: 'Bcrypt uses 59 or 60 characters to hash']
  oauth_registration VARCHAR(4) [Note: 'NULL if local strategy. Otherwise code for platform: google, instagram, facebook, etc']
  is_premium bool [NOT NULL]
  is_early_adopter bool [NOT NULL]
  created_at TIMESTAMP [NOT NULL]
}

Table weights {
  date DATE [not null, note: "Just day, month and year"]
  user_id UUID [ref: > users.id, not null]
  value REAL

  indexes {
    (date, user_id) [pk]
  }
}

Table workouts {
  id UUID [PK, increment]
  template_id UUID [ref: > workout_template.id, not null]
  description VARCHAR(500)
}

Table workout_template {
  id UUID [PK, increment]
  user_id UUID [ref: > users.id, not null]
  name VARCHAR(40) [not null, Note: 'Use alias instead of name due to postgres limitations']
  description VARCHAR(500)

  Note: 'Used for saving templates, executed workouts are stored in workouts_exercises'
}

Table users_workouts {
  user_id UUID [ref: > users.id]
  workout_id UUID [ref: > workouts.id]
  start_date DATE [not null]
  end_date DATE

  indexes {
    (user_id, workout_id, start_date) [pk]
  }
}

Table exercises {
  id UUID [PK, increment]
  name VARCHAR(40) [not null, Note: 'Use alias instead of name due to postgres limitations']
  description VARCHAR(500)
}

Table users_exercises {
  user_id UUID [ref: > users.id]
  exercise_id UUID [ref: > exercises.id]

  indexes {
    (user_id, exercise_id) [pk]
  }
}

Table workout_template_exercises {
  workout_template_id UUID [ref: > workout_template.id]
  exercise_id UUID [ref: > exercises.id]
  exercise_order integer [NOT NULL]
  exercise_sets INTEGER [not null, Note: 'Number of the sets to perform']

  indexes {
    (workout_template_id, exercise_id, exercise_order) [pk]
  }
}

Table workouts_exercises {
  workout_id UUID [ref: > workouts.id]
  exercise_id UUID [ref: > exercises.id]
  exercise_set INTEGER [not null, Note: 'Number of the set']
  exercise_reps INTEGER
  exercise_weight real
  exercise_time_in_seconds INTEGER
  notes VARCHAR(400)

  indexes {
    (workout_id, exercise_id, exercise_set) [pk]
  }
}

Table payments {
  id UUID [PK]
  user_id UUID [ref: > users.id, not null]
  subscription_id UUID [ref: > subscriptions.id, not null]
  amount_in_eur REAL [NOT NULL]
  next_payment_date DATE [Note: 'Just for user info. Actual payment is managed by stripe']
  stripe_subscription_id TEXT
  marked_for_cancel BOOL [not null]
  created_at TIMESTAMP [NOT NULL]
}
